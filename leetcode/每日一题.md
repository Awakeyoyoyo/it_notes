#每日一题

[toc]

###  将字符串翻转到单调递增-2022-06-11

#### 题目

如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。

给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。

返回使 s 单调递增的最小翻转次数。

``` java
示例 1：

输入：s = "00110"

输出：1

解释：翻转最后一位得到 00111.

示例 2：

输入：s = "010110"

输出：2

解释：翻转得到 011111，或者是 000111。

示例 3：

输入：s = "00011000"

输出：2

解释：翻转得到 00000000。
```

#### 思路

> 根据题意可以知道，单调递增的定义就是全部都为000000，或者是1后面全部为1。根据这个信息我们可以知道 要保持单调性，则后一个节点的状态受到前一个节点状态的影响。
>
> 经典dp思维
>
> 定义二维数组`dp[length][2]`,`dp[len][0]`代表着当前len上的节点如果要变化成0时所要的步数，`dp[len][1]`代表着当前len上的节点需要变化成1所需要的步数。
>
> 当前节点为0 的时候，如果要维持单调则下一个节点为0,1都可
>
> 当前节点为   1的时候，下一个节点必须为1
>  



#### 代码实现

```java
class Solution {
    public int minFlipsMonoIncr(String s) {
        int dp[][]=new int[s.length()][2];
        //初始化
        dp[0][0]=s.charAt(0)=='0'?0:1;
        dp[0][1]=s.charAt(0)=='1'?0:1;
        //状态转移
        for (int i = 1; i <s.length() ; i++) {
            dp[i][0]=dp[i-1][0]+(s.charAt(i)=='0'?0:1);
            dp[i][1]=Math.min(dp[i-1][0],dp[i-1][1])+(s.charAt(i)=='1'?0:1);
        }
        return Math.min(dp[s.length()-1][0],dp[s.length()-1][1]);
    }
}
```

