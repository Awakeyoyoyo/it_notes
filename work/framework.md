## 公司底层框架实现原理


### 事件组件。BeanFactoryPostProcessor
    核心思想：通过自定义注解来标识监听事件的方法。在Spring容器中注入BeanFactoryPostProcessor处理器，
    在每个bean注入后，扫描所有带注解方法。利用javassit代码增强，创建出代理类并且用监听事件class为key缓存起来，提供同步抛事件和异步抛事件的方法。抛事件的时候根据class执行对应代理类方法即可。
### 资源配置读取组件

### 缓存-数据库组件
    核心思想：异步定时入库。底层有缓存。并且通过自定义注解标识成员标量，服务启动查库注入常用数据缓存，并且提供一系列数据操作方法。
    
### netty的细节 IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞
    核心思想：boss线程池负责监听端口，worker线程池负责读写io
    
### 线程模型   取mo
    两种：每次都在相同个线程执行的方式（每个角色都固定到某个线程执行）
         每次都在相同任务队列来存储任务，由线程池竞争消费。（每个角色都有自己的任务队列）

### 协议包解析过程 & 请求分发
    采用jprotoful来进行数据的序列化和烦序列化。协议分发则是协议号对应方法来分发。

### 7. 联盟模块
    无非两种方式实现：1、每个玩家都在自己的线程访问 弱一致性 对于公共资源用线程安全容器，并且一些对公共资源操作的方法上锁，例如加入联盟等
                    2、以联盟为一个主体，所有联盟操作都在这个主体的线程执行，比较麻烦的就是一些操作涉及到玩家数据的操作，必须抛到玩家线程执行，代回调之后再进行下一步。需要异步回调，优点无锁化编程且数据肯定是一致的。

### 8.任务系统模块

### 9.排行榜的设计
     排行榜的操作需要上锁
     
### 10. 单服单进程单数据库、单进程多服多数据库、多进程多服多数据库（全球同服）

### 11. MMO游戏中AOI视野检测和 boss处理
    核心思想：订阅与发布。 需要一个中间层来处理。例如地图AOi则将地图分区域，每个区域作为一个注册中心负责管理，玩家负责订阅这个注册中心获取其广播的信息。
    boss的对战也是如此，boss主体作为一个注册中心来实现订阅与发布
    
### 12. zfoo的协议比protobuf快的原因是什么
      zfoo用了字节增强和用了netty的byteBuf。 字节增强使得每次调用都等于对象直接调用。  zfoo字节数小的原因：数值类型进行了压缩算法。而且zfoo支持的语言比较少，很多地方不需要做兼容。所以快

### 13. justloseit线程池模块需要加强：支持异步回调
    使用ComputeFuture，异步返回到当前线程 or 根据指定的params求余返回到指定线程。完毕
    
### 15.如何做到不同区服的玩家可以在同一个逻辑服处理逻辑
    gateWay处理登录 然后生成玩家session，根据负载均衡逻辑（哈希，根据在线数分配）将玩家分配到某个逻辑服处理。保存该玩家session和其所在的逻辑服。数据层面则需要做到根据分库逻辑（服务器id，分区id）来取不同的库拿数据并且缓存。
    退出登录的时候需要清除逻辑服该玩家数据的缓存（好处无需通知各个逻辑服数据变更）， 并且gateWay也需要消除其session（方便下次登录负载均衡到更佳的逻辑服）。这对于公告数据就比较难处理（工会）需要有独立的模块
    还是得根据游戏而定。
    gateWay的使用哈希一致性算法分发，保证相同uid每次都到相同的服务器处理。公共数据模块不好处理：联盟数据等
    gateway滚服的算法一般采用：根据uid解析出sid，根据sid，根据数据库查表得到进程sid对应的进程id，转发到对应的服务进程处理。
    
### 16.gateway和broker的区别
    gateway是对外的是 整体架构对外的接口 需要公网ip地址
    broker是对内 负责内部架构的消息转发，将消息分发的逻辑放在broker处理。逻辑服只需关心将消息发送给broker，broker负责将协议转发即可。
    
### 17.虚拟线程 todo

### 18.逻辑分服
    单进程多服，roleId跟服务器sid有对应关系，数据存储结构最后自带sid，后续无论和合服还是单进程多服都好操作，合服只需要将对应服务器组sids对应关系写好即可
    
### 19.一致性 Hash 算法
    普通的hash算法选择节点保证每一次选择的结果都一样，在新增或者删除节点后，基本所有的选择节点的结果都会改变。（正常我们希望是不改变的，因为线上的数据有缓存 如果大面积更改，会导致缓存数据大面积穿透。） 
    改用成一致性哈希算法可以大大减少选择节点结果更改这种问题。新增或者删除节点也只会影响小部分的节点选择结果
    解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。
    基本原理：
    1）构造一个长度为2的32次方的整数环（这个环被称为一致性Hash环）
    2）根据节点的Hash值（其分布为[0, 2的32次方-1]）将服务器节点放置在这个Hash环上
    3）根据请求的Key值计算得到其Hash值（其分布为[0, 2的32次方-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。
    数据倾斜问题：
    1)服务器节点在哈希圆环上的分布不一定是均匀的。导致大部分请求都指向同一个节点。
    2）在哈希圆环上新增服务器节点，只会影响新增服务器后面的的请求， 负载到该服务器上。 无法准确的全部节点负载均匀，这时候就需要虚拟节点。
    3）为了解决这个问题，最好的办法就是扩展整个环上的节点数量，可以将每台物理缓存服务器虚拟为一组虚拟缓存服务器，使得 Hash 环在空间上的分割更加均匀。
    TreeMap 解决
### 20. TreeMap
    
### 21. 排查线上运行慢问题
    关键词 todo
    Jprofiler定位
    链路追踪
    profile火焰图
    
### 22. springboot父子容器
    springboot包解压，查看MAINEST.MF文件
    找到main class和start class
    springboot启动执行的并不是项目的main
    而是springboot loader模块的JarLauncher
    用一个新的claaloader 去加载一个业务jar
    反射获取JarLauncher，一个服务一个classloader，通过类加载隔离，直接另类实现单进程多服
    
### 23. Rpc模块实现
    1、每个跨服协议包都携带一个信号包，信号包主要有两个状态：1-客户端发出 2-服务端返回
    2、客户端发送完信号包后，将后续响应操作封装到CompleteFuture以信号id为key存储起来
    3、服务端收到信号包，将信号包状态标识标记为2，并且处理相关业务逻辑，随后返回packet和信号包给客户端
    4、客户端收到应答后，根据信号id，拿到对应的CompleteFuture进行回调结果的处理。
    （创建对应的CompleteFuture的时候指定回调后的处理线程，可以保证发送不阻塞Rpc，回调后仍然在发送线程执行）    
    
### 24.微服务
    基于DDD来细说
    
### 25.活動框架

### 26.跨服活动构架
    前提：每个跨服活动都有可能有不同的服务器分组。
    跨服主服负责所有跨服活动的开启，活动开启的时候会根据策划的逻辑（开服天数、分组服务器数量等），将服务器分好组，存储到活跨服动tb中，并将服务器与分组的映像关系存储到数据库中，然后通知从服
    跨服活动开启。从服收到活动开启通知从数据库中读取该活动tb获取其分组与服务器映像关系，然后根据规则（分组id与进程id（配置写死）求余），查找出本跨服要处理哪些分组id，根据分组id就可以找到要
    处理的服务器，进行相关跨服逻辑处理
    网关：网关只负责协议的分发，拿到的只有玩家id与协议号id，分发逻辑跨服逻辑再100000以上分发到跨服服务器，然后网关会有跨服活动的服务器与分组的映像关系，根据玩家id可解析出服务器id，
    即可将该玩家协议转发到对应的跨服服务器进行处理
    需要注意的节点：
    1、活动开启：分组并且存储映像关系，通知从服活动开启
    2、活动关闭：清除映像关系主服通知从服进行关闭处理。

### 27.帧同步

### 28. 路由部分 moduleId和protoId 区分开来
    