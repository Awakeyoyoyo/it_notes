## 公司底层框架实现原理


### 事件组件。BeanFactoryPostProcessor
    核心思想：通过自定义注解来标识监听事件的方法。在Spring容器中注入BeanFactoryPostProcessor处理器，
在每个bean注入后，扫描所有带注解方法。利用javassit代码增强，创建出代理类并且用监听事件class为key缓存起来，提供同步抛事件和异步抛事件的方法。抛事件的时候根据class执行对应代理类方法即可。
### 资源配置读取组件

### 缓存-数据库组件
    核心思想：异步定时入库。底层有缓存。并且通过自定义注解标识成员标量，服务启动查库注入常用数据缓存，并且提供一系列数据操作方法。
### netty的细节 IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞
    核心思想：boss线程池负责监听端口，worker线程池负责读写io
### 线程模型   取mo
    两种：每次都在相同个线程执行的方式（每个角色都固定到某个线程执行）
         每次都在相同任务队列来存储任务，由线程池竞争消费。（每个角色都有自己的任务队列）

### 协议包解析过程 & 请求分发
    采用jprotoful来进行数据的序列化和烦序列化。协议分发则是协议号对应方法来分发。

### 7. 联盟模块
    无非两种方式实现：1、每个玩家都在自己的线程访问 弱一致性 对于公共资源用线程安全容器，并且一些对公共资源操作的方法上锁，例如加入联盟等
                    2、以联盟为一个主体，所有联盟操作都在这个主体的线程执行，比较麻烦的就是一些操作涉及到玩家数据的操作，必须抛到玩家线程执行，代回调之后再进行下一步。需要异步回调，优点无锁化编程且数据肯定是一致的。
### 8.任务系统模块

### 9.排行榜的设计
     排行榜的操作需要上锁
### 10. 单服单进程单数据库、单进程多服多数据库、多进程多服多数据库（全球同服）

### 11. MMO游戏中AOI视野检测和 boss处理
    核心思想：订阅与发布。 需要一个中间层来处理。例如地图AOi则将地图分区域，每个区域作为一个注册中心负责管理，玩家负责订阅这个注册中心获取其广播的信息。
    boss的对战也是如此，boss主体作为一个注册中心来实现订阅与发布
    
### 12. zfoo的协议比protobuf快的原因是什么
      zfoo用了字节增强和用了netty的byteBuf。 字节增强使得每次调用都等于对象直接调用。  zfoo字节数小的原因：数值类型进行了压缩算法。而且zfoo支持的语言比较少，很多地方不需要做兼容。所以快

### 13. justloseit线程池模块需要加强：支持异步回调
    使用ComputeFuture
    
### 15.如何做到不同区服的玩家可以在同一个逻辑服处理逻辑
    gateWay处理登录 然后生成玩家session，根据负载均衡逻辑（哈希，根据在线数分配）将玩家分配到某个逻辑服处理。保存该玩家session和其所在的逻辑服。数据层面则需要做到根据分库逻辑（服务器id，分区id）来取不同的库拿数据并且缓存。
    退出登录的时候需要清除逻辑服该玩家数据的缓存（好处无需通知各个逻辑服数据变更）， 并且gateWay也需要消除其session（方便下次登录负载均衡到更佳的逻辑服）。这对于公告数据就比较难处理（工会）需要有独立的模块
    还是得根据游戏而定。
    gateWay的使用哈希一致性算法分发，保证相同uid每次都到相同的服务器处理。公共数据模块不好处理：联盟数据等
    gateway滚服的算法一般采用：根据uid解析出sid，根据sid，根据数据库查表得到进程sid对应的进程id，转发到对应的服务进程处理。
    
### 16.gateway和broker的区别
    gateway是对外的是 整体架构对外的接口 需要公网ip地址
    broker是对内 负责内部架构的消息转发，将消息分发的逻辑放在broker处理。逻辑服只需关心将消息发送给broker，broker负责将协议转发即可。