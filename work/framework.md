## 公司底层框架实现原理


### 事件组件。BeanFactoryPostProcessor
    核心思想：通过自定义注解来标识监听事件的方法。在Spring容器中注入BeanFactoryPostProcessor处理器，
在每个bean注入后，扫描所有带注解方法。利用javassit代码增强，创建出代理类并且用监听事件class为key缓存起来，提供同步抛事件和异步抛事件的方法。抛事件的时候根据class执行对应代理类方法即可。
### 资源配置读取组件

### 缓存-数据库组件
    核心思想：异步定时入库。底层有缓存。并且通过自定义注解标识成员标量，服务启动查库注入常用数据缓存，并且提供一系列数据操作方法。
### netty的细节 IO 多路复用技术通过把多个 IO 的阻塞复用到同一个 select 的阻塞
    核心思想：boss线程池负责监听端口，worker线程池负责读写io
### 线程模型   取mo
    两种：每次都在相同个线程执行的方式（每个角色都固定到某个线程执行）
         每次都在相同任务队列来存储任务，由线程池竞争消费。（每个角色都有自己的任务队列）

### 协议包解析过程 & 请求分发
    采用jprotoful来进行数据的序列化和烦序列化。协议分发则是协议号对应方法来分发。

### 7. 联盟模块
    无非两种方式实现：1、每个玩家都在自己的线程访问 弱一致性 对于公共资源用线程安全容器，并且一些对公共资源操作的方法上锁，例如加入联盟等
                    2、以联盟为一个主体，所有联盟操作都在这个主体的线程执行，比较麻烦的就是一些操作涉及到玩家数据的操作，必须抛到玩家线程执行，代回调之后再进行下一步。需要异步回调，优点无锁化编程且数据肯定是一致的。
### 8.任务系统模块

### 9.排行榜的设计
     排行榜的操作需要上锁
### 10. 单服单进程单数据库、单进程多服多数据库、多进程多服多数据库（全球同服）

### 11. MMO游戏中AOI视野检测和 boss处理
    核心思想：订阅与发布。 需要一个中间层来处理。例如地图AOi则将地图分区域，每个区域作为一个注册中心负责管理，玩家负责订阅这个注册中心获取其广播的信息。
    boss的对战也是如此，boss主体作为一个注册中心来实现订阅与发布
    
### 12. zfoo的协议比protobuf快的原因是什么
    zfoo用了字节增强和用了netty的byteBuf。 字节增强使得每次调用都等于对象直接调用。  zfoo字节数小的原因：数值类型进行了压缩算法。而且zfoo支持的语言比较少，很多地方不需要做兼容。所以快

### 13. justloseit线程池模块需要加强：支持异步回调
    使用ComputeFuture