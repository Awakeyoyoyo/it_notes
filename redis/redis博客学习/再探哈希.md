## 哈希

### 简介

Hash表也称散列表，也有直接译作哈希表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。它基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。

#### 哈希函数的引入

通过取余，得到一个数被另一个整数除后的余数。首先我们假设要把从0-199的数字（用largeNumber表示），压缩为从0-9的数字（用smallNumber表示），后者有10个数，所以变量smallRange 的值为10，这个转换的表达式为：

> smallNumber = largeNumber % smallRange

当一个数被 10 整除时，余数一定在0-9之间，这样，我们就把从0-199的数压缩为从0-9的数，压缩率为 20 :1。

**这也就是哈希函数。它把一个大范围的数字哈希（转化）成一个小范围的数字，这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。**

#### 哈希冲突

> 把巨大的数字范围压缩到较小的数字范围，那么肯定会有几个不同的单词哈希化到同一个数组下标，即产生了**冲突**。

##### 链地址法 

>  数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中

- 装载因子

  在链地址法中，需要有**N个单元的数组**中转入**N个或更多的数据项**，因此装填因子一般为1，或比1大（有可能某些位置包含的链表中包含**两个或两个以上的**数据项）。

##### 开放地址法

> 开发地址法中，若数据项不能直接存放在由哈希函数所计算出来的数组下标时，就要寻找其他的位置。分别有三种方法：线性探测、二次探测以及再哈希法。

- 装载因子

  已填入**哈希表的数据项**和**表长**的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 2/3。当装填因子不太大时，聚集分布的比较连贯，而装填因子比较大时，则聚集发生的很大了。

- 线性探测法

  在线性探测中，它会线性的查找空白单元。比如如果 5421 是要插入数据的位置，但是它已经被占用了，那么就使用5422，如果5422也被占用了，那么使用5423，以此类推，**数组下标依次递增**，直到找到空白的位置。这就叫做线性探测，因为它沿着数组下标一步一步顺序的查找空白单元。

  当哈希表变得比较满时，我们每**插入一个新的数据，都要频繁的探测插入位**置，因为可能很多位置都被前面插入的数据所占用了，这称**为聚集**。数组填的越满，聚集越可能发生。

- 二次探测法

  二测探测是防止聚集产生的一种方式，思想是探测相距较远的单元，而不是和原始位置相邻的单元。

  线性探测中，如果哈希函数计算的**原始下标是x**, **线性探测**就是x+1, x+2, x+3, 以此类推；而在**二次探测**中，探测的过程是x+1, x+4, x+9, x+16，可能存在的问题就是如果有多个哈希函数后的下表都**是同一个值**，那么会跨越**多次二次探测**，对于数组的大小要求会比较大。

- 再哈希法

  我们知道二次聚集的原因是，二测探测的算法产生的探测**序列步长**总是固定的：1,4，9,16以此类推。那么我们想到的是需要产生一种**依赖关键字的探测序列**，而不是每个关键字都一样，那么，不同的关键字即使映射到相同的数组下标，也可以**使用不同的探测序列**。

  方法是把关键字用**不同的哈希函数**再做一遍哈希化，用这个结果作为**步长**。对于指定的关键字，步长在整个探测中是不变的，不过不同的关键字使用不同的步长

  该哈希函数的特点：1、不能与第一个哈希函数一样 2、不能输出0 否则没有步长，会重复探测。

