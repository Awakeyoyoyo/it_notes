## Redis底层数据结构

### 简单动态字符串(SDS)

```C
struct sdshdr{
    //
    int len;
    int free;
    char buf[];
}
```

- len保存了SDS字符串长度
- buf[]数据用来保存字符串的每个元素
- free 记录了buf数组中未使用的字节数量

比C语言实现多出了len属性和free属性

#### 优点：

**1、常数复杂度获取字符串长度**

由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。

**2、杜绝缓冲区溢出**

我们知道在 C 语言中使用 **strcat 函数**来进行两个字符串的拼接，一旦没有**分配足够长度**的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据**记录的 len 属性检查内存空间**是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。

**3、减少修改字符串的内存重新分配次数**

C语言由于**不记录字符串的长度，**所以如果要修改字符串，必须要重新分配内存（**先释放再申请**），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。

　　而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

　　1、空间预分配：对字符串进行空间扩展的时候，**扩展的内存比实际需要的多**，这样可以减少连续执行字符串增长操作所需的内存重分配次数。**（内存泄漏）**

　　2、惰性空间释放：对字符串进行缩短操作时，程序**不立即使用内存重新分配**来回收缩短后多余的字节，而是使**用 free 属性将这些字节的数量**记录下来，等待后续使用。**（内存泄漏）**（当然SDS也提供了相应的API，当我们有需要时，也可以**手动释放这些未使用**的空间。）

**4、二进制安全**

因为c语言以空字符作为字符串的结束表示，而对一些二进制文件（图片），内容可能包含空字符串，因此c语言的字符串无法正确的存储；

而SDS的API都以处理二进制的方式来处理buf里面的元素，并且SDS不是以空字符来判断是否结束，而是以len属性表示的长度来判断字符串是否结束

#### C语言字符串与SDS之间的区别

| C语言字符串                        | Redis-SDS                                |
| ---------------------------------- | ---------------------------------------- |
| 获取长度时间复杂度On               | 获取长度时间复杂度O1                     |
| API不安全可能造成缓冲区溢出        | API安全，不会造成缓冲区溢出              |
| 修改字符串N次会执行N次内存重新分配 | 修改字符串长度N此最多需要N次内存重新分配 |
| 只能保存文本数据                   | 保存文本数据和二进制数据                 |

### 链表

