Index: springboot/springboot.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/springboot/springboot.md b/springboot/springboot.md
new file mode 100644
--- /dev/null	(date 1659349915610)
+++ b/springboot/springboot.md	(date 1659349915610)
@@ -0,0 +1,321 @@
+## Springboot
+
+[toc]
+
+Springboot作用：
+
+- 可以快速的创建出Spring应用
+
+- 自动的starter依赖，简化了构建配置
+
+- 自动配置了Spring以及第三方功能
+
+- 内嵌了web服务器（打包成jar包、执行即可）
+
+
+
+### 名词解释
+
+#### 微服务
+
+> 微服务是一种架构风格
+>
+> 一个应用拆分成一组小型的服务
+>
+> 每个服务运行在自己的进程中，可以独立部署和升级
+>
+> 服务之间使用轻量级HTTP交互
+>
+> 服务围绕业务功能进行拆分
+>
+> 去中心化，服务自治。服务可以使用不同的语言、不通的存储技术
+
+#### 分布式
+
+> 远程调用：http调用
+>
+> 服务的发现：
+>
+> 负载均衡：
+>
+> 服务容错：
+>
+> 配置管理：配置中心化
+>
+> 链路追踪
+>
+> 日志管理
+
+#### 分布式解决
+
+Springboot+SpringCloud
+
+
+
+
+
+### Springboot的特点
+
+#### 依赖管理
+
+Springboot依赖管理
+
+设置了maven的父工程为spring-boot-starter-parent
+
+```xml
+父工程
+<parent>
+        <groupId>org.springframework.boot</groupId>
+        <artifactId>spring-boot-starter-parent</artifactId>
+        <version>2.2.1.RELEASE</version>
+        <relativePath/> <!-- lookup parent from repository -->
+</parent>
+父工程的父工程
+<parent>
+    <groupId>org.springframework.boot</groupId>
+    <artifactId>spring-boot-dependencies</artifactId>
+    <version>2.2.1.RELEASE</version>
+    <relativePath>../../spring-boot-dependencies</relativePath>
+</parent>
+
+几乎把所有的开发中常用的依赖的版本号都声明好。
+实际开发中只需要引入依赖即可。
+```
+
+- 开发倒入Starter场景启动器
+- 无需关注版本号，由父工程进行管理
+- 可以自定义修改版本号，在实际项目中修改key的值即可
+
+##### spring-boot-start-*
+
+> starters代表着某个开发场景的启动器
+>
+> 只要引入starter，这个场景的所有常规需要的依赖我们都会自动引用（web-aop-jdbc等）
+>
+> 所有场景启动器的最底层依赖都是spring-boot-starter
+
+#### 自动配置
+
+- 自动配置Tomcat
+
+- 自动配置好Web常见功能，字符编码问题、SpringMvc
+
+- 默认的包扫描结构
+
+  > 只要是主程序所在的包以及子包都被默认的扫描
+
+  ```java
+  @SpringBootApplication等同于
+  
+  @SpringBootConfiguration
+  @EnableAutoConfiguration
+  @ComponentScan()
+  ```
+
+- 各种配置拥有默认值
+
+  - 默认配置的值，最终都是映射到*Properties
+
+  ```javaj a
+  @ConfigurationProperties(prefix = "spring.datasource")
+  ```
+
+  - 配置文件的值最终会绑定到每个类上，这个类会在容器中创建对象
+
+- 按需加载所有自动配置项
+
+  - 只有引入了对应的starter才会启动
+  - springboot的自动配置功能都在spring-boot-autoconfigure包里面
+
+### 组件功能
+
+#### @Configuration && @Bean
+
+> 告诉springboot这是一个配置类
+>
+> 1、配置类中使用@Bean注解可以给容器注入组件，代理了xml配置，默认是单例
+>
+> 2、配置类本身也是组件
+>
+> 3、proxyBeanMethods：默认为true，每次检查组件是否在容器中存在，
+>
+> （用于解决配置类中组件注册方法调用是否获取新的对象）
+
+```java
+@Configuration
+public class ShiroConfig {
+    //shiroFilterFactoryBean：3
+    @Bean
+    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier("getDefaultWebSecurityManager") DefaultWebSecurityManager defaultWebSecurityManager){
+        ShiroFilterFactoryBean bean=new ShiroFilterFactoryBean();
+        return bean;
+    }
+}
+```
+
+之前的@compoment、@controller @server还是可以生效的
+
+#### @Import
+
+> 编写于组件类上
+>
+> 参数是数组形式，可以批量导入大量的组件
+
+#### @Conditional
+
+> 条件装配：满足contionditional指定条件，则进行组件的注入
+
+#### @ImportResource
+
+> 导入资源，即xml配置文件的内容解析组件，然后注入到容器中。
+
+#### @ConfigurationProperties
+
+> 用于读取配置文件中的属性 application.properties，注入到组件中
+>
+> - prefix: 前缀
+
+使用的组合：
+
+```java
+@Compoment
+@ConfigurationProperties
+
+@Configuration //必须是配置类
+@EnableConfigurationProperties(xxx.class) //开启xxx.class属性配置功能。并且注入xxx.class
+```
+
+
+
+### 自动配置原理
+
+
+
+> ```javaj a
+> @SpringBootApplication
+> 
+> 
+> @SpringBootConfiguration  //代表当前是个配置类
+> @EnableAutoConfiguration  //
+> @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
+>       @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
+>       public class CommunityApplication {
+>       
+>       }
+> ```
+
+- **@SpringBootApplication**
+
+  - **@SpringBootConfiguration**  //代表当前是个配置类
+
+  - **@EnableAutoConfiguration**  
+
+    - **@AutoConfigurationPackage**
+
+      - **@Import(AutoConfigurationPackages.Registrar.class)**
+
+        - **AutoConfigurationPackages.Registrar.class**
+
+          > 给容器中导入一系列的组件，将mainApplication所在包下的所有组件导入进来
+
+    - **@Import(AutoConfigurationImportSelector.class)**
+
+      1、利用getAutoConfigurationEntry(autoConfigurationMetadata,
+            annotationMetadata);给容器导入部分组件
+
+      2、调用List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);获取所有的需要倒入的autoConfigure组件
+
+      3、List<String> configurations SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
+            getBeanClassLoader()); 利用工厂加载器
+
+      4、从META-INF/spring.factories位置的加载一个文件。
+
+      ​    默认扫描当前系统喜爱所有的META-INF/spring.factories位置的文件
+
+      ![springbootautoconfigura](../images/springbootautoconfigura.png)
+
+      ```XML
+      # Auto Configure
+      org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
+      org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
+      org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
+      org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
+      org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
+      org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
+      ....
+      ```
+
+      autoconfigure的spring.factiries配置文件中写死了容器所要加载的配置类	
+
+      然后每个AutoConfiguration都有自己的判断以及配置属性
+
+  - **@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)**
+
+
+
+#### 自动配置的流程
+
+（1）**@EnableAutoConfiguration**  由多个注解组成
+
+（2）**@Import(AutoConf igurationImportSelector.class)**会每个依赖包从META-INF/spring.factories位置的加载spring.factories文件。
+
+（3）然后springboot-autoconfigure中的spring.factories配置了一大堆容器所要加载的配置类	XXXAutoConfiguration
+
+（4）XXXAutoConfiguration就是每个组件注入的配置类了 
+
+
+
+### RestFul风格
+
+> url资源用名词表示，使用HTTP请求方式动词来表示对于资源的操作。
+
+@RequestMapping(value ="/user",method=RequestMethod.GET)
+
+核心filter：HiddenHttpMethodFIlter
+
+- 用法：表单method=post 隐藏域_method=put
+
+Rest的原理：
+
+- 表单提交会带上 _method=PUT
+- 请求过来会被HiddenHttpMethodFIlter拦截
+  - 请求是否正常，并且是POST
+    - 获取到_method的值
+    - 兼容一下请求PUT_DELETE_PATCH
+    - 原生request（post），包装成了新的requestWrapper的getMethod方法，返回的是传入值
+    - 过滤器链放行的时候使用wrapper，以后调用getMethod方法还是调用RequestWrapper
+
+### 请求映射原理
+
+（1）遍历SpringMVC中的RequestMappingHandler 
+
+ （2）找出符合路径的的handlerMapping
+
+（3）解析参数HandlerMethodArgumentResolver
+
+（3）执行对应的方法
+
+### 数据相应与内容协商
+
+- 相应json
+
+  > @ResponseBody
+
+### 拦截器
+
+#### HandlerInterceptor
+
+- preHandle()
+- postHandle()
+- afterHandle()
+
+
+
+### Error Handing 异常处理器
+
+### Profile功能
+
+![image-20220801182432981](/Users/awakeyoyoyo/Library/Application Support/typora-user-images/image-20220801182432981.png)
+
+
+
Index: redis/redis博客学习/redis数据类型的实现.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## Redis数据类型实现\n\n> Redis有五大数据类型，也有六种数据结构，每种数据类型的实现都使用了一种或者多种数据接口。所以简单介绍下各种数据类型的实现。\n\n### 对象的类型与编码\n\nRedis使用前面说的五大数据类型来表示键和值，每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象，而Redis中的每个对象都是由 redisObject 结构来表示\n\n在Redis中，键是字符串对象，而值则可以使不同的数据类型\n\n#### 数据结构\n\n```c\ntypedef struct redisObject{\n    //类型\n    unsigned type:4;\n    //编码\n    unsigned encoding:4;\n    //指向底层数据结构的指针\n    void *ptr;\n    //引用计数\n    int refcount;\n    //记录最后一次被程序访问的时间\n    unsigned lru:22;\n}robj\n```\n\n- type：记录对象的类型“String、List、Hash、Set、Zset”  `type key`判断对象类型\n- encoding属性 & *prt指针：对象的prt指针指向对象底层的数据结构，而数据结构由encoding属性来决定\n\n**编码常量：**\n\n![redis_encoding](../../images/redis_encoding01.png)\n\n**数据类型对应的不同编码格式实现：**\n\n![redis_encoding02](../../images/redis_encoding02.png)\n\n`OBJECT ENCODING  key`  查看值对象的编码实现\n\n### 字符串对象 string\n\nRedis的最基础的数据类型，字符串的最大长度不超过512M\n\n#### 编码\n\n　字符串对象的编码可以是int，raw或者embstr。\n\n　　1、int 编码：保存的是可以用 long 类型表示的整数值。（保存整数值）\n\n　　2、raw 编码：保存长度大于44字节的字符串   （保存长字符串）\n\n　　3、embstr 编码：保存长度小于44字节的字符串  （保存短字符串） 不可变的结构，因为字符串对象和Redis对象都在**同一片连续**的空间中，修改则需要重新分配空间，直接转化为raw\n\nembstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用**只分配一次内存空间**（因此**redisObject和sds是连续的**），而raw需要**分配两次内存空间**（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个r**edisObject和sds都需要重新分配空**间，因此redis中的embstr**实现为只读**。\n\n**短字符串数据结构:**\n\n![redis_string](../../images/redis_string.png)\n\n**长字符串数据结构:**\n\n![redis_string](../../images/redis_string02.png)\n\n#### 编码转换\n\n当int编码保存的值不再是整数，或者大小超过long的范围会自动转化为raw\n\n对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会**先转化为raw**再进行修改，因此，只要是修改embstr对象，修改后的对象一定是**raw**的\n\n### 列表对象 list\n\n按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），底层实现是一个链表结构。\n\n#### 编码\n\n链表的对象编码可以是ziplist（压缩链表）和linkedlist（双端链表）\n\n> 压缩链表：即省去了双端指针的内存，将一定数量的节点放到同一片连续内存中，内部根据偏移量来访问，不同的大节点之间仍然是用指针访问。 \n\n#### 编码转换\n\n当同时满足下面两个条件时，使用ziplist（压缩列表）编码：\n\n　　1、列表保存元素个数小于512个\n\n　　2、每个元素长度小于64字节\n\n### 哈希对象 hash\n\n哈希对象的键是一个字符串类型，值是一个键值对集合\n\n#### 编码\n\n当使用ziplist，也就是压缩列表作为底层实现时，新增的键值对是保存到压缩列表的表尾。\n\n##### ziplist\n\n![redis_hash](../../images/redishash01.png)\n\nhashtable 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。\n\n##### hashtable\n\n![redis_hash](../../images/redishash02.png)\n\n#### 编码转换\n\n当同时满足下面两个条件时，使用ziplist（压缩列表）编码：\n\n　　1、列表保存元素个数小于512个  \n\n　　2、每个元素长度小于64字节\n\n### 集合对象 set\n\n集合对象 set 是 string 类型，集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。\n\n#### 编码\n\n有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。\n\n集合对象的编码可以是 intset 或者 hashtable。\n\nintset 编码的集合对象使用**整数集合**作为底层实现，集合对象包含的所有元素都被保存在整数集合中。\n\n##### intset :\n\n![hash_set01](../../images/redis_set01.png)\n\nhashtable 编码的集合对象使用 **字典**作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字**典的值则全部设置为 null**。这里可以类比Java集合中HashSet 集合的实现，HashSet 集合是由 HashMap 来实现的，集合中**的元素就是 HashMap 的key**，而 HashMap **的值都设为 null。**\n\n##### hashtable: \n\n![redis_set02](../../images/hash_set02.png)\n\n#### 编码转换\n\n当集合同时满足以下两个条件时，使用 intset 编码：\n\n　　1、集合对象中所有元素都是整数\n\n　　2、集合对象所有元素数量不超过512\n\n### 有序集合对象 \n\n有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。\n\n#### 编码\n\n有序集合的编码可以是 ziplist 或者 skiplist。\n\n　　ziplist 编码的有序集合对象使用**压缩列表**作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，**第一个节点保存元素的成员**，第二个节点保存**元素的分值**。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位\n\n正常情况下：redis使用字典和跳跃表来实现有序集合。\n\n字典的**键保存元素的值**，字典的**值则保存元素的分值**；跳跃表节点的 **object 属性保存元素的成员**，跳跃表节点的 **score 属性保存元素的分值**。\n\n这两种数据结构会通过**指针**来**共享相同元素的成员和分值**，所以不会产生重复成员和分值，造成内存的浪费。\n\n说明：其实有序集合单独使**用字典**或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，**虽然能以 O(1) 的时间复杂度查找成员的分**值，但是因为字典是以**无序的方式来保存集合元素**，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是**查找操作有 O(1)的复杂度变为了O(logN)。**因此Redis使用了两种数据结构来共同实现有序集合。\n\n### 五大类型的应用场景\n\n- 对于string 数据类型，因为string 类型是**二进制安全**的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作**计数器**（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。\n\n- 对于 hash 数据类型，value 存放的是键值对，比如可以做**单点登录存放用户信息**。\n\n- 对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能\n- 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判**断用户名是否注册**；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。\n- 对于 zset 数据类型，有序的集合，可以做范围查找，**排行榜应用，取 TOP N 操作**等。\n\n### Redis内存回收和内存共享\n\n```C\ntypedef struct redisObject{\n    //类型\n    unsigned type:4;\n    //编码\n    unsigned encoding:4;\n    //指向底层数据结构的指针\n    void *ptr;\n    //引用计数\n    int refcount;\n    //记录最后一次被程序访问的时间\n    unsigned lru:22;\n}robj\n```\n\n ##### refcount 属性 引用器计数法  （java是可达性分析算法）\n\n　　1、创建一个新对象，属性 refcount 初始化为1\n\n　　2、对象被一个新程序使用，属性 refcount 加 1\n\n　　3、对象不再被一个程序使用，属性 refcount 减 1\n\n　　4、当对象的引用计数值变为 0 时，对象所占用的内存就会被释放。\n\n会存在着循环引用问题，但是Redis是通过配置maxmemory-policy，来有不同的回收操作。\n\n#### 内存共享\n\n通过如下命令 set k1 100,创建一个键为 k1，值为100的字符串对象，接着通过如下命令 set k2 100 ，创建一个键为 k2，值为100 的字符串对象\n\n1、将数据库键的值指针指向一个现有值的对象\n\n2、将被共享的值对象引用refcount 加 1\n\n![redis_cache](../images/redis_cache.png)\n\n- Redis的共享对象目前只支持整数值的字符串对象\n- 共享对象虽然会降低内存消耗，但是**判断两个对象是否相等**却需要消耗额外的时间\n- 对于**整数值**，判断操作复杂度为O(1)；对于**普通字符串**，判断复杂度为O(n)；而对于**哈希、列表、集合和有序集合**，判断的复杂度为O(n^2)。\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/redis/redis博客学习/redis数据类型的实现.md b/redis/redis博客学习/redis数据类型的实现.md
--- a/redis/redis博客学习/redis数据类型的实现.md	(revision 1196112713e88bafff14c4d25947f6c4860ce261)
+++ b/redis/redis博客学习/redis数据类型的实现.md	(date 1658674477991)
@@ -164,7 +164,7 @@
 
 - 对于string 数据类型，因为string 类型是**二进制安全**的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作**计数器**（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。
 
-- 对于 hash 数据类型，value 存放的是键值对，比如可以做**单点登录存放用户信息**。
+-  对于 hash 数据类型，value 存放的是键值对，比如可以做**单点登录存放用户信息**。
 
 - 对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能
 - 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判**断用户名是否注册**；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
Index: rabbitmq/rabbitMqInstall.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rabbitmq/rabbitMqInstall.md b/rabbitmq/rabbitMqInstall.md
new file mode 100644
--- /dev/null	(date 1659445816796)
+++ b/rabbitmq/rabbitMqInstall.md	(date 1659445816796)
@@ -0,0 +1,51 @@
+## Mac RabbitMq 安装
+
+#### 1、 更新最新版本的Brew
+
+```
+brew update
+```
+
+#### 2、执行安装
+
+``` 
+brew install rabbitmq
+```
+
+- 安装文件路径是在 /usr/local/Cellar/rabbitmq/<版本号>/ , 其实可以在/usr/local/opt/rabbitmq/sbin 进行访问，它也创建一个链接文件在(/usr/local/sbin)
+
+#### 3、创建配置文件 rabbitmq.conf
+
+> brew安装默认不会创建该配置文件
+
+![image-20220802182001665](../images/rabbitmq02.jpeg)
+
+根据官方给的默认路径 创建到对应的地方即可。
+
+[官方配置文件](https://github.com/rabbitmq/rabbitmq-server/blob/v3.8.x/deps/rabbit/docs/rabbitmq.conf.example)
+
+
+
+#### 4、启动rabbitMq
+
+```
+## 启动rabbitmq
+brew services start rabbitmq
+
+## 关闭rabbitmq
+brew services stop rabbitmq
+```
+
+> 访问http://localhost:15672/即可
+
+
+
+#### 5、查看节点配置文件
+
+![image-20220802182001665](../images/rabbitmq03.png)
+
+
+
+
+
+完毕
\ No newline at end of file
Index: effective java/item03&item04.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>### Item03:Enforce the singleton property with a private constructor or an enum type 使用私有构造器或者美剧类强化单例模式\n\n实现单例模式主要由两种方式：这两种方式都要保持构造器为私有的，并且导出共有的静态成员，以便于客户端能够访问该类的唯一实例。\n\n#### 1、用public、final修饰静态成员变量\n\n代码：\n\n```java\npublic class SingletonWithPublicFinalField {\n    public static final SingletonWithPublicFinalField INSTANCE=new SingletonWithPublicFinalField();\n\n    private SingletonWithPublicFinalField(){\n//        if (INSTANCE!=null){\n//            throw new RuntimeException(\"Singleton instance already exists!!!\");\n//        }\n    }\n\n    public void leaveTheBuilding(){\n        System.out.println(\"SingletonWithPublicFinalField.leaveTheBuilding() called...\");\n    }\n}\n```\n\n通过私有化构造方法，构造方法仅被调用一次由此来保证INSTANCE的全局唯一性。一旦INSTANCE实例化则只会存在一个。\n\nMain代码：\n\n```java\n  public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        SingletonWithPublicFinalField instance01=SingletonWithPublicFinalField.INSTANCE;\n        System.out.println(instance01);\n    \t\t//直接调用私有的构造方法会抛出can not access a member of class com.effectiveJava.item03.SingletonWithPublicFinalField with modifiers \"private\" 异常\n\t\t\t\tObject instance03=Class.forName(SingletonWithPublicFinalField.class.getName()).newInstance();\n        System.out.println(instance03);\n        //设置调用SingletonWithPublicFinalField的构造方法的时候不进行权限的检测 即无视private\n        Constructor.setAccessible(SingletonWithPublicFinalField.class.getConstructors(),true);\n        Object instance02=Class.forName(SingletonWithPublicFinalField.class.getName()).newInstance();\n        System.out.println(instance02);\n    }\n```\n\n需要注意客户端借助AccessibleObjcet.setAccessible()方法设置权限的检验，再利用反射调用私有构造器，我们可以添加下列代码，通过抛出Runtime异常的方式来阻止。\n\n```java\n        if (INSTANCE!=null){\n            throw new RuntimeException(\"Singleton instance already exists!!!\");\n        }\n```\n\n由此保证了单例。\n\n#### 2、用private、final修饰静态成员变量，提供方法进行访问\n\n**代码：**\n\n```java\npublic class SingletonWithPublicStaticFactoryMethod {\n    private static final SingletonWithPublicStaticFactoryMethod INSTANCE=new SingletonWithPublicStaticFactoryMethod();\n\n    public SingletonWithPublicStaticFactoryMethod() {\n    }\n\n    public static SingletonWithPublicStaticFactoryMethod getInstance(){\n        return INSTANCE;\n    }\n\n    public void leaveTheBuilding(){\n        System.out.println(\"SingletonWithPublicStaticFactoryMethod.leaveTheBuilding() called...\");\n    }\n\n}\n```\n\nMain代码：\n\n```java\n  public static void main(String[] args){\n        SingletonWithPublicStaticFactoryMethod instance01=SingletonWithPublicStaticFactoryMethod.getInstance();\n        System.out.println(instance01);\n\n    }\n```\n\n如果有学习过单例模式这个一眼可以看到底不需要解释啦哈哈哈哈哈。\n\n##### 1 2-----（番外）序列化\n\n通过添加readResolve()方法使得序列化以及读取序列化对象相同\n\n一个类实现了 Serializable接口, 我们就可以把它往内存地写再从内存里读出而\"组装\"成一个跟原来一模一样的对象. 不过当序列化遇到单例时,就有了问题: 从内存读出而组装的对象破坏了单例的规则. 单例是要求**一个JVM中只有一个类对象的**, 而现在通过反序列化,**一个新的对象克隆了出来**.\n\n如果增加了readResolve()方法，这样当JVM从内存中反序列化地\"组装\"一个新对象时,就会自动调用这个 readResolve方法来返回我们指定好的对象了, 单例规则也就得到了保证. \n\n**代码：**\n\n```java\npublic class SingletonWithSerializable implements Serializable {\n\n    public static final SingletonWithSerializable INSTANCE = new SingletonWithSerializable();\n\n    private SingletonWithSerializable() {\n        if (INSTANCE != null) {\n            throw new RuntimeException(\"Singleton instance already exists!!!\");\n        }\n    }\n\t\t/**\n\t\t保证序列化的单例\n\t\t*/\n//    private Object readResolve(){\n//        return INSTANCE;\n//    }\n\n    public void leaveTheBuilding(){\n        System.out.println(\"SingletonWithSerializable.leaveTheBuilding() called...\");\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        SingletonWithSerializable instance=SingletonWithSerializable.INSTANCE;\n        System.out.println(\"Before serialization: \"+instance);\n\n        try(ObjectOutputStream out=new ObjectOutputStream(new FileOutputStream(\"file1.ser\"))){\n            out.writeObject(instance);\n        }\n        try(ObjectInputStream in=new ObjectInputStream(new FileInputStream(\"file1.ser\"))){\n            SingletonWithSerializable readObject=(SingletonWithSerializable)in.readObject();\n            System.out.println(\"After deserialization: \"+readObject);\n        }\n    }\n}\n```\n\n#### 3、声明一个包含单个元素的枚举类型\n\n（简单安全，无需防止序列化中出现的问题以及多次实例化）这是一个实现单例的最佳方法，但是如果该单例类需要被扩展的话，不适合选择该方法（虽然可让枚举去实现接口且抽取变量）\n\n**代码：**\n\n```java\npublic enum  SingletonWithEnum {\n    INSTANCE;\n\n    public void leaveTheBuilding(){\n        System.out.println(\"SingletonWithEnum.leaveTheBuilding() called...\");\n    }\n\n    public static void main(String[] args) {\n        SingletonWithEnum.INSTANCE.leaveTheBuilding();\n    }\n}\n```\n\n\n\n### Item04: Enforce noninstantiability with a private constructor 通过私有化构造器强制不可实例化\n\n例如在JAVA提供的一些类中，如java.lang.Math、java.ytil.Arrays...等工具类，这些类我们只需调用其静态方法，大多数情况下是不需要实例化的。实例化对于这些工具类是毫无意义的。我们可以通过私有化其一个无参的构造方法且保证只有这个构造方法，这样就可以防止该类的初始化。也可以防止编译器生成缺省构造器。\n\n代码：\n\n```java\npublic class UtilityClass {\n\n    //防止初始化且防止编译器生成缺省构造器\n    private UtilityClass(){\n        throw new AssertionError();\n    }\n}\n```\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/effective java/item03&item04.md b/effective java/item03&item04.md
--- a/effective java/item03&item04.md	(revision 1196112713e88bafff14c4d25947f6c4860ce261)
+++ b/effective java/item03&item04.md	(date 1657172426281)
@@ -1,4 +1,4 @@
-### Item03:Enforce the singleton property with a private constructor or an enum type 使用私有构造器或者美剧类强化单例模式
+### ååItem03:Enforce the singleton property with a private constructor or an enum type 使用私有构造器或者美剧类强化单例模式
 
 实现单例模式主要由两种方式：这两种方式都要保持构造器为私有的，并且导出共有的静态成员，以便于客户端能够访问该类的唯一实例。
 
Index: rabbitmq/rabbitMq.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rabbitmq/rabbitMq.md b/rabbitmq/rabbitMq.md
new file mode 100644
--- /dev/null	(date 1660748026588)
+++ b/rabbitmq/rabbitMq.md	(date 1660748026588)
@@ -0,0 +1,187 @@
+## RabbitMq
+
+[toc]
+
+### MQ的优势
+
+- 应用解耦
+
+- 提高系统吞吐量（单位时间内处理请求的数目）
+- 消峰填谷（提高系统的稳定性） 将消息存放到mq中，系统按需来处理维持峰值运行，不会越过最高峰
+- 异步处理
+
+### MQ的劣势
+
+- 系统的可用性降低
+
+  > 系统引入的外部依赖越多，系统的稳定性就越差，需要额外保证MQ的高可用
+
+- 系统的复杂度提高
+
+  > 引入MQ之后系统之间的调用由同步的远程调用，转变成MQ的异步调用，需要保证消息没有被重复消费，处理消息丢失，消息传递的顺序性问题。
+
+- 一致性问题
+
+  > ABC系统需要同时完成，加入C系统失败了，那么AB系统的数据需要保证一致性，回滚或者其他操作
+
+### 使用MQ的场景
+
+- 生产者不需要从消费者获取反馈，即调用的远程方法不需要返回值
+- 允许短暂的不一致性
+
+
+
+
+
+### AMQP协议
+
+高级消息队列协议，是一个网络协议，类似于HTTP，基于此协议在客户端和消息中间件中传递消息。
+
+#### AMQP模型的三大组件
+
+- 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
+- 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
+- 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。
+
+### JMS
+
+> JMS就是java消息服务应用程序接口，是一个java平台中关于面向消息中间件的API
+>
+> JMS类似于JDBC就是提供连接MQ实现的
+
+### RabbitMq端口
+
+访问的url
+
+> http://localhost:15672/#/
+
+![image-20220802182001665](../images/rabbitmq01.png)
+
+### RabbitMq 工作模式
+
+> 工作模式的不同主要是 路由设置的不同
+>
+> 交换机的类型主要有：
+>
+> - Fanout：广播,发送消息到每一个与之绑定的队列
+> - Direct：定向
+> - Topic：通配符方式，
+> - headers:
+
+#### Work Queues工作队列模式
+
+![image-20220802182001665](../images/rabbitmq04.png)
+
+> 一个生产者 -> 队列 -> 多个消费者
+>
+> 消息直接发送给消息队列
+
+#### Pub/Sub 订阅模式
+
+![image-20220802182001665](../images/rabbitmq05.png)
+
+> 引入了Exchange 交换机，将消息发送给交换机，通过交换机将消息分发到不同的消息队列中。
+>
+> 交换机类型：
+>
+> Fanout：广播,发送消息到每一个与之绑定的队列
+
+#### Rounting 路由工作模式
+
+![image-20220802182001665](../images/rabbitmq06.png)
+
+> 队列与交换机不再是任意得绑定了，而是指定一个RoutingKey（路由key）
+>
+> 消息在发送的过程中必须指定Exchange（交换机）和RoutingKey（路由key）
+>
+> Exchange交换机不再把消息分发给每一个与之绑定的队列，而是根据消息的RoutingKey进行判断
+>
+> 交换机类型 Direct：定向的根据RoutingKey来分发到对应队列
+
+#### Topics 通配符模式
+
+![image-20220802182001665](../images/rabbitmq07.png)
+
+> 交换机类型 Topics
+>
+> 与路由工作模式原理类似。
+
+### RabbitMQ高级特性
+
+> 消息从生产者发送到路由器再根据路由key 分发到不同的队列再被消费者消费
+
+#### 消息的可靠性
+
+##### 生产者
+
+使用rabbitMq的时候，作为消息的发送发希望杜绝任何消息丢失或者投递失败场景。RabbitMq为我们提供了两种控制消息投递可靠性模式
+
+**confirm** 确认模式
+
+> 消息从生产者到交换机的时候会返回一个confirmCallback
+>
+> 可以知道消息是否成功的分发到我们的交换机
+>
+> spring.rabbitmq.publisher-confirm-type=correlated
+
+**return** 退回模式
+
+> 当消息从生产者成功交换到交换机，再从交换机到队列路由失败时才会执行returnCallback 
+>
+> 可以知道消息是否成功的分发到我们的队列中
+
+##### Consumer ACK 消费者
+
+ack指Acknowledge，确认。表示消费端收到消息后的确认方式。
+
+有三种确认方式：
+
+- 自动确认：acknowledge=”none“   收到消息之后就确认
+
+- 手动确认：acknowledge=”manual“ 等待业务处理无问题再手动代码确认
+
+#### 消费端限流
+
+> 消费MQ消息的时候进行限流 
+
+配置 prefetch属性，消息端一次拉取多少消息
+
+消费端的确认模式必须为手动
+
+#### TTL(存活时间和过期时间)
+
+> 当消息达到存活时间后，还未被消费，会被自动清除
+>
+> RabbitMQ可以对消息设置过期时间，也可以队伍整个队列设置过期时间
+
+#### 死信队列
+
+> 当消息成为Dead Message后，可以被重新发送到另外一个交换机，这个交换机就是DLX
+
+
+
+消息成为死信的情况
+
+- 队列消息达到限制
+- 消费者拒绝接受消费信息，
+- 队列存在消息过期设置，或者是消息已达到过期时间
+
+![image-20220802182001665](../images/rabbitmq09.png)
+
+（1）声明死信队列、死信交换机
+
+（2）正常的队列绑定死信交换机。设置死信交换机名称和roudingKey
+
+#### 延迟队列
+
+> 即消息进入队列之后不会被立即消费，只有达到指定时间才会被消费
+
+使用TTL和死信队列组合来实现 延迟队列的效果。
+
+![image-20220802182001665](../images/rabbitmq10.png)
+
+#### 日志与监控
+
+##### RabbitMQ日志
+
+RabbitMQ的存储位置 /var/log/rabbitmq/rabbit@xxx.log
\ No newline at end of file
Index: work/面试题.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/work/面试题.md b/work/面试题.md
new file mode 100644
--- /dev/null	(date 1660880785019)
+++ b/work/面试题.md	(date 1660880785019)
@@ -0,0 +1,838 @@
+[toc]
+
+### Redis
+
+##### 1.Redis的基础数据结构类型有？
+
+> String：字符串类型，特点是二进制安全，可以存放序列化后的各种对象
+>
+> set：不可重复的集合
+>
+> Zset：有序的集合，通过分数来进行排序
+>
+> hash：存放key value
+>
+> List：简单的队列
+>
+> - 对于string 数据类型，因为string 类型是**二进制安全**的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作**计数器**（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。
+>
+> -  对于 hash 数据类型，value 存放的是键值对，比如可以做**单点登录存放用户信息**。
+>
+> - 对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能
+> - 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判**断用户名是否注册**；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
+> - 对于 zset 数据类型，有序的集合，可以做范围查找，**排行榜应用，取 TOP N 操作**等。
+
+##### 2.说一下Redis的两种持久化方式？
+
+> Redis的持久化方式重要有两种，分别是RDB和AOF两种，
+>
+> RDB的就是存储当前数据的快照，后面恢复数据直接恢复到存储的快照版本。
+>
+> AOF就是存储增删的操作，后门恢复数据就是将所有的操作语句重新执行。
+
+##### 3、redis的集群和哨兵机制和主从机制
+
+首先redis的集群有三种方式：哨兵模式、主从模式、cluster模式
+
+- 主从机制
+
+> 将多个redis实例分为一个Master主节点，多个从机Slave节点。
+>
+> Master主机负责解决写操作，Slave从机只负责读，将读写操作分离
+
+- 哨兵机制--基于主从机制
+
+> 哨兵模式作用：在主节点挂掉之后，从节点能够自动变成主节点，避免无法进行写操作的情况。
+
+- cluster模式（分布式存储）
+
+> Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N
+>
+> 然后通过哈希槽方式来访问redis，每个redis都有固定的槽位，集群中用相同的算法了求出key对应的槽位进而选择对应的redis访问
+
+### Spring
+
+##### 1.说一下Spring？
+
+> spring是一个java的基础框架，它的特点主要是两个方面IOC和AOP，首先IOC是控制反转的意思，在Spring中是通过IOC容器来管理对象之间的依赖和生命周期的，而AOP就是通过动态代理来增加方法，抽取公共的逻辑代码，主要实现是通过spring的BeanPostProcessor来实现。
+
+##### 2.IOC容器的理解？
+
+> 用于管理对象之间的依赖和生命周期的容器，依赖注入：将java对象由创建者进行管理改为由IOC容器进行管理。
+
+##### 3.AOP的理解？
+
+> 通过动态代理来增强方法的实现，可以抽取公共的逻辑出来：常见的使用有日志打印等，主要实现是通过spring的BeanPostProcessor来实现。
+
+##### 4.容器启动的过程？
+
+> （1） 通过BeanDefinitionReader下的子类，不同子类有不同的读取方式，如xml、注解的形式，读取将来会用到的Bean来生成对应的BeanDefinition信息
+>
+> （2）**设置容器的配置信息**，设置容器的awake接口会生效
+>
+> （3）**执行注册的BeanFactoryPostProcessor接口中的方法**，要用于对读取后的BeanDefinition来进行处理，我们可以定制自己的处理器来插手容器的创建过程，PlaceHolderBeanFactoryPostProcessor处理配置文件中占位符问题
+>
+> （4）注册处理bean生命周期的BeanPostProcessor 
+>
+> （5）注册事件监听器等
+>
+> （6）容器的初始化完成，然后初始化非懒加载且单例的Bean
+
+##### 5.bean的生命周期？
+
+> （1）首先Bean被依赖，Spring容器中又没有此时就触发了Bean的初始化
+>
+> （2）根据反射生成一个Bean的对象
+>
+> （3）然后根据BeanDefinition来初始化Bean的属性
+>
+> （4）根据Bean所实现的Aware接口来注入对应属性 常见：上下文
+>
+> （5）执行BeanPostProcessor的before方法
+>
+> （6）执行Bean配置的的init方法
+>
+> （7）执行BeanPostProcessor的After方法 
+>
+> （8）得到完整的Bean对象放入容器中
+
+##### 6.循环引用问题？
+
+> A对象的成员变量有B，B的成员变量中有A。这样就会产生循环引用，Spring中通过三级缓存的方式来解决循环引用，其中一级缓存：存储的是已经完整的对象，二级缓存中存储的是实例化好的对象，三级缓存中存储的是构建对象的lambda表达式（用于方便构建代理对象）。构建代理对象需要依赖真的对象，那么className就会对应代理对象和真的对象，造成混乱，所以需要三级缓存。
+>
+> 无法解决在构造器下的循环依赖
+
+### Springboot
+
+##### 1.什么是 Spring Boot?
+
+> Springboot在我的理解上是一个框架的框架，它可以帮助我们轻松的整合我们需要使用的框架的依赖，例如就是构建好一些常用框架的starter，我们只需要引入该依赖就可使用该框架功能，可以帮助我们减少使用xml文件来注入bean，默认就有自动配置类来注入bean，并且约定好再application配置文件中可以配置常见的框架的使用的变量值。还整合了servlet容器tmocat可以直接运行。
+
+##### 2.SpringBoot的核心注解有哪些及其作用？
+
+##### 3.Springboot自动配置的流程
+
+（1）**@EnableAutoConfiguration**  由多个注解组成
+
+（2）**@Import(AutoConf igurationImportSelector.class)**会每个依赖包从META-INF/spring.factories位置的加载spring.factories文件。
+
+（3）然后springboot-autoconfigure中的spring.factories配置了一大堆容器所要加载的配置类	XXXAutoConfiguration
+
+（4）XXXAutoConfiguration就是每个组件注入的配置类了 
+
+### Java基础
+
+##### 1.StringBuilder和StringBuffer哪个是线程安全？
+
+> StringBuilder线程安全。
+
+##### 2.HashMap和HashTable的区别？
+
+> 首先两者的底层实现都是数组+链表的数据结构实现的，数组用于hash处理，链表用于解决hash冲突，但如果达到某些条件的话链表会自动转换成红黑树，提高查询速度。
+>
+> 最大的区别是HashMap是线程不安全的，HashTable是线程安全的，HashTable底层在一些会造成并发安全的操作上都进行了上锁操作，而且一锁就是整个容器锁住，建议使用ConcurrentHashMap，ConcurrentHashMap底层采用了分段锁的技术，锁的粒度减少了，性能会比较好。
+
+##### 3.HashMap为什么是线程不安全的？
+
+> 多个线程同时插入相同key的value时，就会有线程安全问题，本质上就是一个不同线程同时修改一个对象的问题。会出现覆盖的问题。
+
+##### 4.线程的生命周期？
+
+> 线程的[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)包含5个阶段，包括：
+>
+> **新建:**线程刚被创建出来后
+>
+> **就绪**:就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段。
+>
+> **运行:**获得了CPU资源执行对应的代码的状态
+>
+> **阻塞:**在运行状态的时候
+>
+> - 调用了wait（） 需要上锁，并且调用notify来唤醒
+> - 调用了sleep（） 需要等待时间结束
+> - 等待IO流的输入输出
+>
+> **死亡**:代码执行完毕，抛出异常。
+
+##### 5.线程池的作用？
+
+> 线程池是比较宝贵的资源，不适宜频繁的创建和销毁，线程池的作用就是管理好线程的生命周期，当需要使用到的时候就到线程池中去拿，不需要自己额外的创建线程，将底层策略交给线程池。
+>
+> 提一下项目的线程池模型。  类似于Redis的分片 保证了每次的操作都是去对应的线程执行
+
+##### 6.三大类型线程池？
+
+> Executors.newSingleThreadExecutor() //单个线程的线程池
+>
+> Executors.newFixedThreadPool(100) //固定大小的线程池
+>
+> Executors.newCachedThreadPool() // 可伸缩的线程池
+
+##### 7.七大参数？
+
+> - corePoolSize, //核心线程池大小
+> - maximumPoolSize,    //最大核心线程池大小
+> - keepAliveTime,     //超时了没有人调用就会释放
+> - TimeUnit unit,          //超时单位
+> - BlockingQueue<Runnable> workQueue, //阻塞队列
+> - ThreadFactory threadFactory,       //线程工厂，创建线程的，一般不动
+> - RejectedExecutionHandler handler)  //拒绝策略
+
+```java
+//本质开启线程池调用了ThreadPoolExecutor()
+    public ThreadPoolExecutor(int corePoolSize, //核心线程池大小
+                              int maximumPoolSize,    //最大核心线程池大小
+                              long keepAliveTime,     //超时了没有人调用就会释放
+                              TimeUnit unit,          //超时单位
+                              BlockingQueue<Runnable> workQueue, //阻塞队列
+                              ThreadFactory threadFactory,       //线程工厂，创建线程的，一般不动用
+                              RejectedExecutionHandler handler) { //拒绝策略
+        if (corePoolSize < 0 ||
+            maximumPoolSize <= 0 ||
+            maximumPoolSize < corePoolSize ||
+            keepAliveTime < 0)
+            throw new IllegalArgumentException();
+        if (workQueue == null || threadFactory == null || handler == null)
+            throw new NullPointerException();
+        this.corePoolSize = corePoolSize;
+        this.maximumPoolSize = maximumPoolSize;
+        this.workQueue = workQueue;
+        this.keepAliveTime = unit.toNanos(keepAliveTime);
+        this.threadFactory = threadFactory;
+        this.handler = handler;
+    }
+```
+
+##### 8.四种拒绝策略？
+
+没有空闲的线程，且任务队列已经满了
+
+> - new ThreadPoolExecutor.AbortPolicy() //线程满了还有线程要进入则,不做处理,直接抛出异常
+> - new ThreadPoolExecutor.CallerRunsPolicy() //由调用线程执行对应的任务
+> - new ThreadPoolExecutor.DiscardPolicy() //队列满了丢掉任务,不进行处理，不会抛出异常!
+> - new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃队列中第一个任务，重新提交任务
+
+##### 9. 线程池池的最大的线程如何去设置? 
+
+了解:IO密集型与CPU密集型
+
+> IO密集型：  例如处理网络IO，IO输入输出，   2*N+1
+>
+> CPU密集型： 线程执行基本不会进入阻塞状态的，N+1
+
+##### 10.什么是JUC
+
+> JavaUtil三个处理线程安全问题的包
+
+##### 11.并发和并行的区别？
+
+> 并发：多个线程共同操作同一个资源
+>
+> 并行：多个CPU或者是多个线程同时执行
+
+##### 12.Lock锁和Synchronized锁的区别
+
+> synchronized是内置的java关键字而Lock是一个接口
+> synchronized无法判断获取锁的状态,Lock可以判断是否获取到了锁
+> synchronized会自动释放锁,Lock必须要手动释放锁！否则会造成死锁.
+> synchronized 线程1(获得锁,阻塞),线程2(等待,傻傻的等);Lock锁就不会一直等下去
+> synchronized 可重入锁 不可以中断的 非公平,Lock 可重入锁 可以判断的 非公平(可以设置)
+> synchronized 适合锁少量同步代码,Lock适合锁大量同步代码.
+
+##### 13.CountDownLatch类?
+
+> 主要用于某一个线程等待其他线程执行完毕后再执行的累，当数量变为0之后就会唤醒主线程继续执行。
+>
+> 原理:当每次有线程调用 countDown()方法则数量减一,假设数量变为0，await()方法就会被唤醒继续执行！
+
+##### 14.四大函数式接口(必须掌握)
+
+> lambda表达式，链式编程，函数式接口，Stream流式计算
+
+函数式接口：只有一个方法的借口
+
+##### 15.Future 异步回调？
+
+> Futrue我的理解就是对于未来的某个执行结果进行操作，而且future的对于未来的结果的处理是默认是在当前现场执行的。
+
+##### 16.ArraList和LinkList的区别?
+
+> 首先是底层的数据结构不同，ArrayList的底层实现是数组，LinkList的底层实现是链表，然后由于数据结构的不同呢，ArrayList的访问单个元素的速度是比链表快的，可以直接通过下标的形式来访问，但是ArrayList会存在内存浪费的情况，因为数组的话需要事先申请空间且是根据阈值来进行扩容，所以申请空间的大小不等于所有元素的大小。而如果是频繁的插入的话使用LinkList会比较好，因为是链表的形式，只需要改变指针的方向即可，而数组的插入会讲后续的元素都后移一位。 然后遍历速度在大数据量的情况下是数组比较快，因为空间是连续的，不需要每次都读取下一个元素的地址，可以直接计算出来。
+
+##### 17.给出一个父子类，里面有各种实例变量，静态变量，静态代码块，实例代码块，里面有打印语句，然后要求说说各个打印顺序
+
+##### 18.二维数组，分别从行遍历和列遍历，哪个快？
+
+##### 19.A<? etends E> , A<? super E> 的区别
+
+> extends：表明该A类是E的子类
+>
+> super：表示A类是只能是E的负累
+
+##### 20. AQS，ComccurentHashMap,CAS?
+
+AQS：核心就是用一个int变量来表示锁的状态，并且用一个先进先出的队列来控制阻塞队列，实现锁的机制
+
+CAS：比较再交换，即每次都获取最新的值，然后计算，然后再设置回去的时候再比较与获取的值是否相同，相同才设置。java底层保证了最后一步的获取比较设置是原子性。
+
+##### 21.Enum<E extends Enum > 是什么？
+
+这样子是为了让class参数化，并且限制了Class的类型，我们在该类中的方法中返回对象的时候，可以返回子类对象类型。
+
+##### 22.java序列化与反序列化？
+
+##### 4.Thread.sleep()和Object.wait()调用时线程处于什么状态？
+
+> 现场处于阻塞的状态，等待自然唤醒或者是其他线程notify唤醒
+
+### JVM
+
+##### 1.说一下JVM的内存分布?
+
+> 堆：存储对象的地方
+>
+> 栈：存储方法执行的数据结构
+>
+> 虚拟机栈：存储本地方法执行的数据结构
+>
+> 程序计数器：存储指令的执行编号
+>
+> 方法区：存储类对象以及常量的地方
+
+##### 2.说一下垃圾回收算法?
+
+首先垃圾回收算法主要有 标记清除、标记清除整理、复制三种。标记清除就是根据可达性分析算法，标记出已经死去的对象，然后清除。主要用于老年代。
+
+复制算法：讲内存分为三块，一块大内存：survier 两块同等大小的小内存区域：eden。根据可达性分析算法，标记出survier和旧eden中存活的对象然后复制到新eden中，然后清空survier和旧eden。
+
+可达性算法：主要是规定好root对象，然后对于与root对象有引用链关系的对象标记成是存活的，没有引用链关系的对象就标示为死亡对象。其中root对象有：栈中的方法里面的引用、虚拟机栈中的引用、方法区中常量的引用、类金泰属性的引用
+
+##### 3.说一下类加载的过程？
+
+当程序主动使用某个类的时候，如果该类还没被加载到内存中，那么就会触发类的加载。
+
+过程是
+
+1、加载：根据类名将class文件加载到内存中，在堆中创建java类对象，指向方法区中类的数据
+
+2、链接 ：校验类的正确性，解析引用，将static final修饰的变量都会在clinit放啊放中。
+
+3、初始化：开始执行类定义的java的程序代码<clinit>()方法，并且加载一个类的时候会先加载其父类，所以会先执行父类的clinit方法 static包裹的代码块和
+
+
+
+
+
+1、加载
+
+> - 通过一个类的全限定名获取该类的二进制流。
+> - 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
+> - 在内存中生成该类的Class对象，作为该类的数据访问入口。
+
+2、验证
+
+> 检验class文件的安全性
+
+3、准备
+
+> 是为类的静态变量分配内存并将其初始化为默认值，
+
+4、解析
+
+> 将类里面的符号引用替换成直接引用
+
+5、初始化
+
+> 开始执行类定义的java的程序代码<clinit>()方法，并且加载一个类的时候会先加载其父类，所以会先执行父类的clinit方法 static包裹的代码块和
+
+6、使用
+
+7、卸载
+
+
+
+类加载器：主要就是负责将类加载到内存中，
+
+有三种类加载器：
+
+- 启动类加载器：加载Java的核心库
+
+- 拓展类加载器：加载依赖jar包
+
+- 应用类加载器：加载项目代码的
+
+还可以自定义类加载器继承[抽象类](https://so.csdn.net/so/search?q=抽象类&spm=1001.2101.3001.7020)java . lang.ClassLoader类，修改其loadClass方法。
+
+类加载器的特点：
+
+**1.全盘负责**：当一个类加载器加载一个类时，该类所依赖的其他类也会被这个类加载器加载到内存中。
+**2.缓存机制**：所有的Class对象都会被缓存，当程序需要使用某个Class时，类加载器先从缓存中查找，找不到，才从class文件中读取数据，转化成Class对象，存入缓存中。
+
+**3.双亲委派机制**：即把请求交由父类处理,它是一种任务委派模式。父类无法处理才到子类进行处理。避免类的重复加载
+
+在JVM中,即使这两个类对象(class对象)来源同一个Class文件,被同一个虚拟机所加载,但只要加载它们的ClassLoader实例对象不同,那么这两个类对象也是不相等的。
+
+##### 4.如何实现热更？
+
+1、需要编写属于自己的classLoader，因为默认的应用类classLoader会缓存已经加载的class，不会重新加载。并且热更需要移除旧的类，我们只需要把旧的classLoader移除即可。
+
+修改双亲委托机制 跳过应用类加载器。
+
+2、监听class文件的变化，然后调用Class.forName来主动的用自己的classLoader来加载新的类
+
+3、class的卸载，将就的classLoader置空等待gc回收
+
+### 数据库
+
+##### 1.事务的四大特征？
+
+> 原子性：事务中的操作要么全部执行，要么全部不执行
+>
+> 隔离性：事务和事务之间是隔离开的. 一个事务看不到另一个事务正在操作的数据，互不影响
+>
+> 一致性：事务操作前后，保证数据从一个正确的状态到另一个正确的状状态
+>
+> 持久性： 一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中
+
+##### 2.MYSQL的索引什么时候失效？
+
+- 条件中有or，即使其中有条件带索引也不会使用；
+- 对于多列索引，不使用的第一部分，则不会使用索引；
+- like查询以%开头，索引无效；
+- 当字段类型为字符串时，条件中数据没有使用引号引用。
+- 避免在 where 子句中对字段进行 null 值判断
+
+##### 3、建立索引需要注意什么？
+
+- 经常需要作为条件来查询的列
+- 有顺序且经常需要范围查询的列
+- 不要在有大量相同取值的字段建立索引
+- 经常修改的字段不建立索引
+
+
+
+
+
+##### 3.关系型数据库和非关系型数据库之间的区别？
+
+> 关系型数据库就是有固定的表结构，但是基本是存储在硬盘上
+>
+> 非关系型数据库就是存储格式是key value的形式，可以存放在内存中
+
+##### 5.Mysql的隔离级别
+
+- 读未提交
+
+  > 事务中的修改，即使未提交，对于其他事务也是可见的。
+
+- 读已提交
+
+  > 一个事务只能读取已经提交的事务所做的修改，即使一个事务所做的修改在提交之前对于其他事务都是不可见的。
+
+- 可重复读
+
+  > 保证在同一个事务中多次读取同一数据的结果是一样的
+
+- 串行化
+
+  > 强制事务串行执行，这样多个事务互不干扰。读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。
+
+### 网络层
+
+##### 1.说一下网络分为哪五层？
+
+- 应用层：http协议
+- 传输层：TCP和UDP
+- 网络层：IP
+- 链路层：MAC地址
+- 物理层
+
+##### 2.TCP和UDP的区别？
+
+> TCP是面向连接的协议，是可靠传输，是面向字节流的，应用层的数据会先传输到TCP缓存区再由TCP协议来发送报文
+>
+> UDP是面向报文传输的，无需建立连接，没有连接状态，应用层发送的报文多大就传输多大。
+
+##### 3.TCP三次握手？
+
+- 第一次握手，客户端把自身的序号携带上发给服务端
+- 第二次握手，服务端收到第一次握手报文，纪录下客户端的序号，返回响应，并且携带上自身的序号
+- 第三次握手，客户端收到了服务端的响应报文，记下服务端的序号，然后握手完成可以开始传输数据
+
+##### 4.TCP为什么不两次握手？ 为什么不四次握手？
+
+- 首先TCP协议在传输层
+
+- 为什么不是两次？
+
+  需要确认同步双方的初始序列号
+
+- 为什么不是四次？
+
+  因为服务端在三次握手过后，双方的序列号已经确定了，无需额外的第四次。
+
+##### 5.TCP四次挥手
+
+- 关闭方先发送关闭请求过来，然后进入关闭1状态
+- 被动关闭方收到关闭请求，返回关闭响应，进入等待关闭状态
+- 被动关闭方再把未传输完信息发送过去，主动放收到之后进入手动关闭状态
+- 关闭方发送正式关闭响应
+
+### Netty
+
+##### 1.Netty 是什么？
+
+Netty是基于nio的一个网络通信框架，它封装了jdk的nio，让我们可以方便的使用nio来处理连接。 并且保持了一个高并发下的高性能。它实现高性能的核心是它背后的I/O模型和线程模型
+
+首先它的I/O模型采用的是高性能epoll/select 模型，是一个IO多路复用模型 NIO，由selector来管理多个连接是否准备就绪
+
+I/O多路复用模型有三种：
+
+- select ：每次都遍历文件描述符（与远程传输的抽象符号）来查询哪些已经传输完毕了，用数组来存储文件描述符。 有连接数量的限制
+
+- poll：每次都遍历文件描述符（与远程传输的抽象符号）来查询哪些已经传输完毕了，用链表来存储文件描述符。  没有数量的限制
+
+- epoll：通过回调的方式来触发数据接收。无需遍历。减少了遍历的时间并且可以没有连接数量的限制
+
+它的线程采用的是Reator模型
+
+主要有两个线程池，boss线程池和worker线程池。boss线程池负责注册连接到selecter上并且监听是否已完成连接，如果已经是完成连接则将channel注册到worker线程池。从中选取一个NioEventLoo注册，当IO可读的时候就进行读写
+
+##### 2.粘包和拆包问题
+
+拆包：一个完整的应用包可能会被 TCP 拆分成多个包进行发送。
+
+粘包：也可能把小应用包的封装成一个大的 TCP数据包发送。
+
+消息头指定好消息体的长度，在channel中读取的时候进行长度的判断
+
+##### 3.netty默认启动的线程数
+
+Netty的默认启动了电脑可用线程数的两倍，在调用了bind方法的时候执行。
+
+##### 4.netty channel有消息了如何分发到对应的线程执行？
+
+channel中有引用指向对应的NioEventLoop来让其执行。
+
+### 工作
+
+##### 1.你们们持久化是异步的，那么怎么保证数据不丢失呢？
+
+> 我说持久化的方式有两种，一种是异步的，一种是同步的，缓存失效的时候会进行保存，停服的时候会将所有有更新的数据都入库一边，入库失败会不断的重试。
+
+##### 3.线程模型？ 
+
+> 账号对应线程池。hashPool
+>
+> 创建的线程池中每条线程有自己独立的任务队列，然后根据账号的不同将任务提交到不同的线程的任务队列中。
+>
+> 账号对应队列。forkJoinPool
+>
+> 创建线程池，和一个任务队列的集合，根据账号的不同把任务分发到不同的任务队列中，而线程池是自动获取任务队列集合中的进行消费。因为每执行完一个任务才从任务队列中移除该任务，
+
+##### 4.协议包解析请求分发
+
+> 自定义的协议包里面包括了 包头、协议号、长度和byte数组的数据部分。 包头里面传输特定密钥，保证传输的完全性，长度用于解决粘包和拆包的问题，协议号用于进行分发请求，byte数组就是数据部分
+>
+> 分发请求的处理：自定义注解 ，在每个controller的方法体上加该注解，并且加上协议号。在Sping容器启动完成后扫描所有Bean，将标示了该注解的方法 缓存起来，用协议号和方法缓存起来，后续分发的时候根据协议号直接调用该方法。方法需要统一参数。
+
+##### 4.事件机制
+
+> 简单来说就是通过自定义注解的方式，在定义一个通用的处理事件的Manager类，在Spring容器启动完成后扫描所有的bean，将监听事件的方法用事件class与方法集合存储起来，提供方法抛出事件，然后执行所有的监听方法。
+
+##### 5.缓存机制
+
+> 底层使用的是GUAVA cache的框架，缓存过期的时间是30分钟，也是通过自定义注解的形式来实现，定义manager来管理所有的入库的实例，主要的查询数据库的地方有 在查询缓存中没有的时候，在玩家第一次登陆的时候加载玩家数据。
+
+##### 6.配置加载机制
+
+> 读取到配置文件，按照一定的格式对文件内容进行解析，将内容封装到javaBean里面，然后放入集合中，利用自定义注解 注入到每个标示了该注解的成员变量上
+
+##### 7. 排行榜的实现？
+
+> 猜测是使用链表的结构来实现，根据值来上下的浮动。
+
+##### 6.消息队列出现积压情况？
+
+>  出现了积压那就是消费者出现了问题嘛，首先得恢复消费者。
+
+##### 8.ProtoBuf可以二进制传输，那说说Java对象的序列化，它有什么特点，序列化UID又是什么?
+> java对象的序列化的特点是他可以让一个对象跨越不同的jvm虚拟机来进行传输。得到属性相同的对象。每个需要序列化的对象类都需要实现**Serializable**接口。这个接口是一个标识的作用。序列化UID是为了保证反序列化回来的对象和与之对应的java类是同一个版本的
+
+
+
+##### 9.CSRF攻击原理与解决方法？
+
+
+
+##### 10.#{}和${}的区别是什么?
+
+\#{}是预编译处理，${}是字符串替换。
+
+Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的set 方法来赋值；
+
+Mybatis 在处理${}时，就是把${}替换成变量的值。
+
+使用#{}可以有效的防止 SQL 注入，提高系统安全性
+
+##### 11.联盟模块的实现原理
+
+采用锁的方式实现，成员变化需要锁住整个联盟的对象，成员变量采用并发安全的集合等，读的时候直接访问，不需要上锁来访问，保证若一致性即可。
+
+##### 12.圣物模块
+
+类似于一套装备系统，属性树的原理：编写对应的树的分支，定义好每个节点的类型-就是class的类型
+
+##### 13.战斗模块
+
+lua战斗服。
+
+战斗的校验：前端发起战斗请求，后段存储战斗id以及对应的BattleInfo（teamInfo）。前端打完后将BattleResult返回，然后对于战斗id相同且胜利的战斗进行校验，主要是用存储的battleInfo去跑一遍战斗。
+
+### spring cloud
+
+##### 1.微服务？
+
+##### 2.Spring Could的各个组件？ 
+
+### 消息队列RabbitMQ
+
+##### 1.RabbitMQ是什么？
+
+>  RabbitMQ是一个消息中间件，
+
+##### 2.AMQP模型的几大组件？
+
+> - 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
+> - 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
+> - 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。
+
+##### 3.说说生产者Producer和消费者Consumer?
+
+> 生产者就是负责生产消息，消费者就是负责消费消息的。
+
+##### 4.为什么需要消息队列？
+
+##### 5.说说Broker服务节点、Queue队列、Exchange交换器？
+
+> Broker服务器节点就相当于一个MQ实例，里面可以有很多的队列和很多的交换器
+>
+> Queue队列就是存储消息的队列，与交换机绑定，由交换机分发消息到对应的队列中
+>
+> 交换器就是将生产者下发的消息根据绑定的规则分发到不同的队列中。
+
+##### 6.什么是RoutingKey路由键？
+
+> RabbitMQ的分发消息的依据是 先分发到路由上，再根据路由key来分发到不同的队列中
+
+##### 8.如何保证消息的可靠性？
+
+- confirm 确认模式
+
+> 消息从生产者到交换机的时候会返回一个confirmCallback
+>
+> 可以知道消息是否成功的分发到我们的交换机
+>
+> spring.rabbitmq.publisher-confirm-type=correlate
+
+- return 退回模式
+
+> 当消息从生产者成功交换到交换机，再从交换机到队列路由失败时才会执行returnCallback 
+>
+> 可以知道消息是否成功的分发到我们的队列中
+
+##### 9.交换器4种类型？
+
+- Fanout：广播,发送消息到每一个与之绑定的队列
+- Direct：定向
+- Topic：通配符方式，
+- Headers: 通过headers属性来分配
+
+##### 10.生产者消息运转？
+
+##### 11.消费者接收消息过程？
+
+##### 12.死信队列？导致死信的即中原因
+
+**死信队列：**
+
+当消息成为Dead Message后，可以被重新发送到另外一个交换机，这个交换机就是DLX，由这个交换机可以分发到的队列就叫作死信队列。
+
+**死信的原因：**
+
+- 队列消息达到限制
+- 消费者拒绝接受消费信息，
+- 队列存在消息过期设置，或者是消息已达到过期时间
+
+##### 13.延迟队列，如何实现
+
+通过设置队列中信息的过期时间，然后绑定好对应的死信队列就可以实现。
+
+##### 14.发送确认机制
+
+生产者发送消息到交换机的时候，会返回一个comfirm回调方法。可以确认消息是否成功到达交换机
+
+##### 15.生产者如何将消息可靠投递到MQ？
+
+- Client发送消息给MQ
+
+- MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；
+
+### 面筋
+
+##### 1.讲一下ArrayList和LinkList的区别？使用场景？
+
+>  ArrayList的底层实现是数组的形式，而LInklist的底层实现是链表的形式，ArrayLIst由于数组，数组的长度是需要固定的，长度不一定等于容器的长度，会有内存的浪费，但是由于是数组的形式可以通过下标来访问所以访问快， 而ArrayList的话则是元素的数量等于链表实际消耗的内存大小，节省内存，但是访问的话就需要遍历的方式来访问某个元，比较耗时。对于需要频繁的访问的建议使用ArrayList，如果是数据量大且不需要根据下标来访问的话使用LinkLIst比较好，不会有太多的内存浪费
+
+##### 2.ArrayList插入的逻辑？答：讲了点扩容的东西
+
+> 插入的话会判断是否达到容器的扩容阈值，如果达到则会申请更大的内存空间，然后把旧数组的内容copy过去。
+
+#####  3. LinkList做聊天记录的存储的话，如果是定长的，有什么数据结构可以更好的替代吗？
+
+> 首先，聊天记录的话最需要的是按照下标多少到多少来进行获取和遍历，所以最好的还是通过数组的形式来进行代替，并且是定长的话就不存在随着纪录的增多，数组扩容造成大量的空间浪费。并且数组在大数据的情况下遍历的速度比较快
+
+##### 4.两种List遍历全部谁快，原理？答：
+
+>  ArrayList，因为地址是连续的，然后取的时候不用通过拿去下一个引用的地址去查找。直接就可以计算访问
+
+##### 5.HashMap和TreeMap的区别？
+
+> 底层的数据结构不一样，HashMap的底层是数组+链表或者红黑树的形式。TreeMap的底层实现就是红黑树，HashMap的存储是无序的，而TreeMap的存储是有序。
+
+##### 6.HashMap如果发生hash碰撞怎么办？
+
+> 如果发生的hash碰撞，那么会用链表的形式存储起来，即同一个hash key指向一个链表，其中存放着hash冲突的value
+
+##### 7.HashMap底层的构造是什么样子？
+
+> HashMap的底层是数组+链表的形式，特殊情况则会存在红黑树的结构
+
+##### 8. 虚拟机里面有几种结构？
+
+> 程序计数器 用于执行记录指令的编号
+>
+> 堆 存储对象的地方
+>
+> 栈 存储方法执行的内存模型
+>
+> 虚拟机栈 存储本地方法执行的内存模型
+>
+> 方法区 存储 类信息、静态常量的地方
+
+##### 9.堆的内存大小如何分配？答：主要讲了几个设置的参数。
+
+> 堆大小，我们可以控制的是整个堆的大小，还可以控制新生代、老年代的大小。都可以通过参数进行控制
+
+##### 10. 问了垃圾回收器的搭配？答：讲了CMS+ParNew的组合还有G1收集器，说项目用的G1
+
+##### 11.G1的特性，优缺点。答：照着JVM来说
+
+- 可通过参数来控制控制的停顿时间
+
+G1会把内存分成一块一块，并且每一块内存都是有新生代老年代之分，新生代就分为Eden和Suervier。然后每块内存也是有优先级别的用队列来维持，根据预留的停顿时间来先回收优先级别高的内存块
+
+##### 12.G1什么时候进行Young GC？答：分配内存时，内存不够的时候...（感觉说了废话），然后说了一下G1没有那么强的分代概念，会回收收益高的Region,可以设置期望最大停顿时间的参数等.
+
+> 在创建新对象的时候，发现新生代的内存不足以支持该对象的创建，或者新生代对象创建后达到了阈值，就会进行Young GC
+
+##### 13.Volatile的用法，有什么优点，能不能并发修改，比如用在整形上？答：从工作内存和主内存讲解，原理，还有不能并发修改的原因。
+
+> 首先jvm的内存结构就是每个线程都有自己的工作内存，其中工作内存中的变量都与主内存的相等，而Volatile的作用就是为了保证工作内存中的变量与主内存中的变量保持一致，即某个变量被volatile修饰，当主内存中变量发生变化后，某个线程在读取该变量的时候发现版本不一致，会获取主内存中最新的变量。
+>
+> 不能保证并发修改安全，因为读取的时候保证是一致的，但是读取和修改并不是原子性的操作，比如两个线程同时的进行读取，然后修改，79->80, 两个现场都给该值+1，预想记过是81，但可能会出现是80的情况。
+
+##### 14. ClassLoader的机制？答：7个阶段，还有双亲委派机制的内容。
+
+##### 15.设计一款自己的ClassLoader，有什么用法？答：继承，然后实现loadClass()方法。
+
+##### 16.New了两个一模一样的ClassLoader，去load同一个class文件，load进来的类会相等吗？
+
+答：不相等，比较两个对象是否相等有个就是比较是否同一个构造器，不是同一个则不相等。
+
+ 
+
+##### 17.那这两个会共享一份加载类缓存吗？答：不会，因为是不同的构造器对象，每个有自己的一份缓存..后面再问缓存相关的就不懂了...
+
+##### 18.根据ClassLoader讲解热更机制？答：讲了JVMTI还有Java Instrumentation API的原理，还有agent，还有自己项目的情况。
+
+##### 19.如果设计一款自己的ClassLoader，想修改线上的方法类参数，怎么设计？答：讲解了热更不能新增删除方法，也不能更改方法的参数之类的，但对方还是追问如果想呢？我就讲了别的方案，但对方说就是想加参数，直接说不会。
+
+##### 20.用wait/notify实现生产者消费者？
+
+首先就是生产的代码和消费的代码都需要上锁，然后锁里面 生产者先判断库存是否已满，满了就调用wait方法，如果生产就调用notify唤醒消费者。 而消费者进行消费，如果库存不足则使用wait，消耗完库存就调用notify唤醒生产者。
+
+##### 21.如果消费者阻塞太久怎么办？答：可以用wait(time)，对方说还是太久呢?感觉是坑，这套机制本来消费者没有消息过来就是得阻塞。
+
+ 
+
+G1 jvm
+
+
+
+
+
+
+
+
+
+
+
+|      |      |      |      |
+| :--- | ---- | ---- | ---- |
+|      |      |      |      |
+|      |      |      |      |
+|      |      |      |      |
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
